# Wolfram

## ELEMENTARY CELLULAR AUTOMATON

The goal of this project is to implement Wolfram’s elementary cellular automaton in the terminal.

https://en.wikipedia.org/wiki/Elementary_cellular_automaton

We only have to implement rule 30, rule 90 and rule 110. The other rules are considered a bonus.

The space our cellular automaton are living in is infinite (to the left, right, and bottom).
This means the parts not shown on screen can still have an effect on future generations.

```
We have to handle the handling of the arguments yourself. Getopt is forbidden.
```

## INVOCATION

Our program must support the following options:

- –rule : the ruleset to use (no default value, mandatory)
- –start : the generation number at which to start the display. The default value is 0.
- –lines : the number of lines to display. When omitted, the program never stops.
- –window : the number of cells to display on each line (line width). If even,
    the central cell is displayed in the next cell on the right. The default value is 80.
- –move : a translation to apply on the window. If negative, the window is translated to the left.
    If positive, it’s translated to the right.

If no option or invalid options are provided our program must return 84 and display a usage message
(eventually accompagned with an explicite error message of our choice)

## HINTS

The main purpose of this project is to let us re-discover Haskell and improve our functional programming
skills.
Considering it’s simplicity, we should (and are expected) to produce the cleanest code possible. This project
is a great opportunity to use some of the great features of Haskell, such as pattern matching and guards,
partial application and currying of functions, higher order functions and closures, isolation of side effect
ridden code from pure code.

```
Each topics seen during the Paradigm Seminar can be used in this project
We can finish the project without using some of them, but using them will result in a better project.
```

## BONUS

- Support all the 256 possible rules.


## BUILD WITH STACK

Stack is a convenient build tool/package manager for Haskell.
Its use is required for this project, with **version 2.1.3 at least**.

It wraps a build tool, either **Cabal** or **hpack**.
We are required to use the hpack variant (package.yaml file in our project, autogenerated .cabal file).

```
This is what stack generates by default with stack new.
```
Stack is based on a package repository, **stackage** , that provides consistent snapshots of packages.
The version we use must be in the **LTS 20** series (resolver:'lts-20.11'in stack.yaml).

```
In stack.yaml, extra-dependencies cannot be used.
```
**base** is the only dependency allowed in thelibandexecutablesections of our project (package.yaml).
There is no restriction on the dependencies of thetestssections.

```
We must provide a Makefile that builds our stack project (i.e. it should at some point call ‘stack build’).
```
```
‘stack build’ puts our executable in a directory that is system-dependent , which we may want to copy.
A useful command to learn this path in a system- independent way is:
stack path --local-install-root.
```

## FINAL MARK

### MARK: 21 / 21 (100%)

- Basics (1 / 1)
- Rule 30 (3 / 3)
- Rule 90 (3 / 3)
- Rule 110 (3 / 3)
- Infinite (1 / 1)
- Window and move (2 / 2)
- Performance (3 / 3)
- Error handling (5 / 5)
